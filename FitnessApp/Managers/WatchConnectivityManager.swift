import Foundation
import WatchConnectivity

@MainActor
class WatchConnectivityManager: NSObject, ObservableObject {
    static let shared = WatchConnectivityManager()
    
    @Published var isWorkoutActive = false
    @Published var workoutData: [String: Any] = [:]
    
    private override init() {
        super.init()
        if WCSession.isSupported() {
            WCSession.default.delegate = self
            WCSession.default.activate()
            print("游릭 Watch: WCSession is supported and activated")
            print("游릭 Watch: Session is reachable: \(WCSession.default.isReachable)")
        } else {
            print("游댮 Watch: WCSession is not supported")
        }
    }
    
    func sendWorkoutData(_ data: [String: Any]) {
        guard WCSession.default.activationState == .activated else {
            print("游댮 Watch: Session is not activated")
            return
        }
        
        guard WCSession.default.isReachable else {
            print("游댮 Watch: iPhone is not reachable")
            return
        }
        
        print("游릭 Watch: Sending workout data: \(data)")
        
        workoutData = data
        isWorkoutActive = true
        
        do {
            try WCSession.default.updateApplicationContext(data)
            print("游릭 Watch: Data sent successfully")
        } catch {
            print("游댮 Watch: Error sending data: \(error.localizedDescription)")
        }
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        if let error = error {
            print("游댮 Session activation failed with error: \(error.localizedDescription)")
        } else {
            print("游릭 Session activated successfully with state: \(activationState)")
        }
    }
    
    nonisolated func session(_ session: WCSession, didReceiveApplicationContext applicationContext: [String : Any]) {
        print("游릭 Received application context: \(applicationContext)")
        
        guard session.activationState == .activated else {
            print("游댮 Session is not activated")
            return
        }
        
        DispatchQueue.main.async {
            if applicationContext["workoutEnded"] as? Bool == true {
                print("游릭 Workout ended notification received")
                self.isWorkoutActive = false
                self.workoutData = [:]
                LiveActivityManager.shared.endLiveActivity()
                return
            }
            
            print("游릭 New workout data received")
            self.isWorkoutActive = true
            
            let wasEmpty = self.workoutData.isEmpty
            self.workoutData = applicationContext
            
            if wasEmpty {
                print("游릭 Starting new Live Activity")
                LiveActivityManager.shared.startLiveActivity(with: applicationContext)
            } else {
                print("游릭 Updating existing Live Activity")
                LiveActivityManager.shared.updateLiveActivity(with: applicationContext)
            }
        }
    }
    
    nonisolated func sessionDidBecomeInactive(_ session: WCSession) {
        print("游리 Session became inactive")
    }
    
    nonisolated func sessionDidDeactivate(_ session: WCSession) {
        print("游리 Session deactivated, attempting to reactivate")
        WCSession.default.activate()
    }
}
